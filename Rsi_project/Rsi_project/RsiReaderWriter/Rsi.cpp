///////////////////////////////////////////////////////////////////////////////
// Rsi.cpp
#include "TcPch.h"
#pragma hdrstop

#include "Rsi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CRsi
BEGIN_INTERFACE_MAP(CRsi)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_IRsi, IRsi)
///</AutoGeneratedContent>
END_INTERFACE_MAP()


IMPLEMENT_ITCOMOBJECT(CRsi)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2_RT(CRsi)
IMPLEMENT_ITCADI(CRsi)
IMPLEMENT_ITCWATCHSOURCE(CRsi)

///////////////////////////////////////////////////////////////////////////////
// Set parameters of CRsi 
BEGIN_SETOBJPARA_MAP(CRsi)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CRsi 
BEGIN_GETOBJPARA_MAP(CRsi)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CRsi
BEGIN_OBJPARAWATCH_MAP(CRsi)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CRsi
BEGIN_OBJDATAAREA_MAP(CRsi)
///<AutoGeneratedContent id="ObjectDataAreaMap">
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
// Constructor
CRsi::CRsi()
	: m_Trace(m_TraceLevelMax, m_spSrv)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
///</AutoGeneratedContent>
}

///////////////////////////////////////////////////////////////////////////////
// Destructor
CRsi::~CRsi() 
{
}

///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI_RT(CRsi)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP possibly RT context
//
// Initialize input parameters 
// Allocate memory
HRESULT CRsi::SetObjStatePS_RT(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CRsi::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	
	// TODO: Add any additional initialization

	if (FAILED(hr))
	{
		// TODO: Cleanup if initialization failed
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CRsi::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Revert transition from SAFEOP to OP

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP possibly in RT context
HRESULT CRsi::SetObjStateSP_RT()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// TODO: Revert transition from PREOP to SAFEOP

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}


double CRsi::get_axis_1()
{
    return ax1;
}

double CRsi::get_axis_2()
{
    return ax2;
}

double CRsi::get_axis_3()
{
    return ax3;
}

double CRsi::get_axis_4()
{
    return ax4;
}

double CRsi::get_axis_5()
{
    return ax5;
}

double CRsi::get_axis_6()
{
    return ax6;
}

double CRsi::get_external_axis_1()
{
    return external_axis1;
}
///</AutoGeneratedContent>



bool CRsi::find_substring(const string& msg, const string& target, int& position, int start_index, int end_index)
{

    INT16 target_length = target.length();
    INT16 msg_length = msg.length();

    if (end_index == -1)
    {
        for (INT16 i = start_index; i < msg_length - target_length; i++)
        {
            string candidate;
            for (INT16 ii = 0; ii < target_length; ii++)
            {
                candidate += msg[i + ii];
            }
            if (candidate == target)
            {
                position = i;
                return true;
            }
        }
    }
    else
    {
        if (start_index > end_index)
        {
            return false;
        }
        if (end_index > msg_length)
            return false;

        for (INT16 i = start_index; i < end_index; i++)
        {
            string candidate;
            for (INT16 ii = 0; ii < target_length; ii++)
            {
                candidate += msg[i + ii];
            }
            if (candidate == target)
            {
                position = i;
                return true;
            }
        }
    }
    //cout << "ERROR: missing substring: " << target << endl;
    return false;
}


bool CRsi::read_cartesian_based_tag(const string& msg, const string& tag, double& x, double& y, double& z, double& rot1, double& rot2, double& rot3)
{
    int start_tag;
    if (!find_substring(msg, tag, start_tag))
        return false;

    string target = "/>";
    int end_tag;
    if (!find_substring(msg, target, end_tag, start_tag))
        return false;

    target = "X";
    int x_arg_index;
    if (!find_substring(msg, target, x_arg_index, start_tag, end_tag))
        return false;

    target = "Y";
    int y_arg_index;
    if (!find_substring(msg, target, y_arg_index, start_tag, end_tag))
        return false;

    target = "Z";
    int z_arg_index;
    if (!find_substring(msg, target, z_arg_index, start_tag, end_tag))
        return false;

    target = "A";
    int rot1_arg_index;
    if (!find_substring(msg, target, rot1_arg_index, start_tag, end_tag))
        return false;

    target = "B";
    int rot2_arg_index;
    if (!find_substring(msg, target, rot2_arg_index, start_tag, end_tag))
        return false;

    target = "C";
    int rot3_arg_index;
    if (!find_substring(msg, target, rot3_arg_index, start_tag, end_tag))
        return false;

    // Find beginning and end of of argument value

    target = "\"";
    int x_value_start;
    if (!find_substring(msg, target, x_value_start, x_arg_index, y_arg_index))
        return false;

    target = "\"";
    int x_value_end;
    if (!find_substring(msg, target, x_value_end, x_value_start + 1, y_arg_index))
        return false;

    target = "\"";
    int y_value_start;
    if (!find_substring(msg, target, y_value_start, y_arg_index, z_arg_index))
        return false;

    target = "\"";
    int y_value_end;
    if (!find_substring(msg, target, y_value_end, y_value_start + 1, z_arg_index))
        return false;

    target = "\"";
    int z_value_start;
    if (!find_substring(msg, target, z_value_start, z_arg_index, rot1_arg_index))
        return false;

    target = "\"";
    int z_value_end;
    if (!find_substring(msg, target, z_value_end, z_value_start + 1, rot1_arg_index))
        return false;

    target = "\"";
    int rot1_value_start;
    if (!find_substring(msg, target, rot1_value_start, rot1_arg_index, rot2_arg_index))
        return false;

    target = "\"";
    int rot1_value_end;
    if (!find_substring(msg, target, rot1_value_end, rot1_value_start + 1, rot2_arg_index))
        return false;

    target = "\"";
    int rot2_value_start;
    if (!find_substring(msg, target, rot2_value_start, rot2_arg_index, rot3_arg_index))
        return false;

    target = "\"";
    int rot2_value_end;
    if (!find_substring(msg, target, rot2_value_end, rot2_value_start + 1, rot3_arg_index))
        return false;

    target = "\"";
    int rot3_value_start;
    if (!find_substring(msg, target, rot3_value_start, rot3_arg_index, end_tag))
        return false;

    target = "\"";
    int rot3_value_end;
    if (!find_substring(msg, target, rot3_value_end, rot3_value_start + 1, end_tag))
        return false;

    x = atof(msg.substr(x_value_start + 1, x_value_end - x_value_start).c_str());
    y = atof(msg.substr(y_value_start + 1, y_value_end - y_value_start).c_str());
    z = atof(msg.substr(z_value_start + 1, z_value_end - z_value_start).c_str());
    rot1 = atof(msg.substr(rot1_value_start + 1, rot1_value_end - rot1_value_start).c_str());
    rot2 = atof(msg.substr(rot2_value_start + 1, rot2_value_end - rot2_value_start).c_str());
    rot3 = atof(msg.substr(rot3_value_start + 1, rot3_value_end - rot3_value_start).c_str());

    return true;
}


bool CRsi::read_joint_based_tag(const string& msg, const string tag, double& ax1, double& ax2, double& ax3, double& ax4, double& ax5, double& ax6)
{
    // Find beginning and end of the AIPos tag

    int start_tag;
    if (!find_substring(msg, tag, start_tag))
        return false;

    string target = "/>";
    int end_tag;
    if (!find_substring(msg, target, end_tag, start_tag))
        return false;

    // Find begining position of each argument

    target = "A1";
    int ax1_arg_index;
    if (!find_substring(msg, target, ax1_arg_index, start_tag, end_tag))
        return false;

    target = "A2";
    int ax2_arg_index;
    if (!find_substring(msg, target, ax2_arg_index, start_tag, end_tag))
        return false;

    target = "A3";
    int ax3_arg_index;
    if (!find_substring(msg, target, ax3_arg_index, start_tag, end_tag))
        return false;

    target = "A4";
    int ax4_arg_index;
    if (!find_substring(msg, target, ax4_arg_index, start_tag, end_tag))
        return false;

    target = "A5";
    int ax5_arg_index;
    if (!find_substring(msg, target, ax5_arg_index, start_tag, end_tag))
        return false;

    target = "A6";
    int ax6_arg_index;
    if (!find_substring(msg, target, ax6_arg_index, start_tag, end_tag))
        return false;

    // Find beginning and end of of argument value

    target = "\"";
    int ax1_value_start;
    if (!find_substring(msg, target, ax1_value_start, ax1_arg_index, ax2_arg_index))
        return false;

    target = "\"";
    int ax1_value_end;
    if (!find_substring(msg, target, ax1_value_end, ax1_value_start + 1, ax2_arg_index))
        return false;

    target = "\"";
    int ax2_value_start;
    if (!find_substring(msg, target, ax2_value_start, ax2_arg_index, ax3_arg_index))
        return false;

    target = "\"";
    int ax2_value_end;
    if (!find_substring(msg, target, ax2_value_end, ax2_value_start + 1, ax3_arg_index))
        return false;

    target = "\"";
    int ax3_value_start;
    if (!find_substring(msg, target, ax3_value_start, ax3_arg_index, ax4_arg_index))
        return false;

    target = "\"";
    int ax3_value_end;
    if (!find_substring(msg, target, ax3_value_end, ax3_value_start + 1, ax4_arg_index))
        return false;

    target = "\"";
    int ax4_value_start;
    if (!find_substring(msg, target, ax4_value_start, ax4_arg_index, ax5_arg_index))
        return false;

    target = "\"";
    int ax4_value_end;
    if (!find_substring(msg, target, ax4_value_end, ax4_value_start + 1, ax5_arg_index))
        return false;

    target = "\"";
    int ax5_value_start;
    if (!find_substring(msg, target, ax5_value_start, ax5_arg_index, ax6_arg_index))
        return false;

    target = "\"";
    int ax5_value_end;
    if (!find_substring(msg, target, ax5_value_end, ax5_value_start + 1, ax6_arg_index))
        return false;

    target = "\"";
    int ax6_value_start;
    if (!find_substring(msg, target, ax6_value_start, ax6_arg_index, end_tag))
        return false;

    target = "\"";
    int ax6_value_end;
    if (!find_substring(msg, target, ax6_value_end, ax6_value_start + 1, end_tag))
        return false;

    ax1 = atof(msg.substr(ax1_value_start + 1, ax1_value_end - ax1_value_start).c_str());
    ax2 = atof(msg.substr(ax2_value_start + 1, ax2_value_end - ax2_value_start).c_str());
    ax3 = atof(msg.substr(ax3_value_start + 1, ax3_value_end - ax3_value_start).c_str());
    ax4 = atof(msg.substr(ax4_value_start + 1, ax4_value_end - ax4_value_start).c_str());
    ax5 = atof(msg.substr(ax5_value_start + 1, ax5_value_end - ax5_value_start).c_str());
    ax6 = atof(msg.substr(ax6_value_start + 1, ax6_value_end - ax6_value_start).c_str());

    return true;
}


bool CRsi::read_external_axis_based_tag(const string& msg, const string tag, double& e_axis1)
{
    // Find beginning and end of the AIPos tag

    int start_tag;
    if (!find_substring(msg, tag, start_tag))
        return false;

    string target = "/>";
    int end_tag;
    if (!find_substring(msg, target, end_tag, start_tag))
        return false;

    // Find begining position of each argument

    target = "E0";
    int e_ax1_arg_index;
    if (!find_substring(msg, target, e_ax1_arg_index, start_tag, end_tag))
        return false;

    // Find beginning and end of of argument value

    target = "\"";
    int e_ax1_value_start;
    if (!find_substring(msg, target, e_ax1_value_start, e_ax1_arg_index, end_tag))
        return false;

    target = "\"";
    int e_ax1_value_end;
    if (!find_substring(msg, target, e_ax1_value_end, e_ax1_arg_index + 1, end_tag))
        return false;

    e_axis1 = atof(msg.substr(e_ax1_value_start + 1, e_ax1_value_end - e_ax1_value_start).c_str());

    return true;
}


bool CRsi::read_tag_no_arg_uint(const string& msg, const string& tag, uint32_t& value)
{
    int start_tag;
    if (!find_substring(msg, "<" + tag + ">", start_tag))
        return false;

    string target = "</" + tag + ">";
    int end_tag;
    if (!find_substring(msg, target, end_tag, start_tag))
        return false;

    value = atoi(msg.substr(start_tag + tag.length() + 2, end_tag).c_str());

    return true;
}


double CRsi::get_axis_1_setpoint()
{
	return ax1_setpoint;
}

double CRsi::get_axis_2_setpoint()
{
	return ax2_setpoint;
}

double CRsi::get_axis_3_setpoint()
{
	return ax3_setpoint;
}

double CRsi::get_axis_4_setpoint()
{
    return ax4_setpoint;
}

double CRsi::get_axis_5_setpoint()
{
	return ax5_setpoint;
}

double CRsi::get_axis_6_setpoint()
{
	return ax6_setpoint;
}

double CRsi::get_external_axis_1_setpoint()
{
    return external_axis1_setpoint;
}

double CRsi::get_cartesian_x_setpoint()
{
	return x_setpoint;
}

double CRsi::get_cartesian_y_setpoint()
{
	return y_setpoint;
}

double CRsi::get_cartesian_z_setpoint()
{
	return z_setpoint;
}

double CRsi::get_cartesian_rot1_setpoint()
{
	return rot1_setpoint;
}

double CRsi::get_cartesian_rot2_setpoint()
{
	return rot2_setpoint;
}

double CRsi::get_cartesian_rot3_setpoint()
{
	return rot3_setpoint;
}

double CRsi::get_cartesian_x()
{
	return x;
}

double CRsi::get_cartesian_y()
{
	return y;
}

double CRsi::get_cartesian_z()
{
	return z;
}

double CRsi::get_cartesian_rot1()
{
	return rot1;
}

double CRsi::get_cartesian_rot2()
{
	return rot2;
}

double CRsi::get_cartesian_rot3()
{
	return rot3;
}

USHORT CRsi::write_msg(ULONG max_length_msg, char* msg, double ax1, double ax2, double ax3, double ax4, double ax5, double ax6, double external_axis1)
{
   
    char* buffer;
    buffer = new char[max_length_msg];
    memset(buffer, 0, max_length_msg);
    
    USHORT length =sprintf(buffer, "<Sen Type=\"ImFree\">\n\t<AK A1=\"%f\" A2=\"%f\" A3=\"%f\" A4=\"%f\" A5=\"%f\" A6=\"%f\" />\n\t<EK E0=\"%f\"/>\n\t<IPOC>%i</IPOC>\n</Sen>\n", ax1, ax2, ax3, ax4, ax5, ax6, external_axis1, ipoc);

    memcpy(msg, buffer, length);

    delete[] buffer;

	return length;
}

HRESULT CRsi::read_incoming_msg(ULONG nStr, char* msg)
{
    HRESULT hr = S_OK;

    const string current_joints_pos_tag = "AIPos";
    const string setpoint_joints_pos_tag = "ASPos";
    const string current_cartesian_pos_tag = "RIst";
    const string setpoint_cartesian_pos_tag = "RSol";
    const string current_external_axis_pos_tag = "EIPos";
    const string setpoint_external_axis_tag = "ESPos";
    const string ipoc_tag = "IPOC";

    const int msg_length = std::min(int(nStr), 1024);
    char* buffer = new char[msg_length];
    
    memcpy(buffer, msg, msg_length);

    if (!read_joint_based_tag(buffer, current_joints_pos_tag, ax1, ax2, ax3, ax4, ax5, ax6))
        return S_FALSE;
    
    if (!read_joint_based_tag(buffer, setpoint_joints_pos_tag, ax1_setpoint, ax2_setpoint, ax3_setpoint, ax4_setpoint, ax5_setpoint, ax6_setpoint))
        return S_FALSE;

    if (!read_external_axis_based_tag(buffer, current_external_axis_pos_tag, external_axis1))
        return S_FALSE;

    if (!read_external_axis_based_tag(buffer, setpoint_external_axis_tag, external_axis1_setpoint))
        return S_FALSE;
    
    if (!read_cartesian_based_tag(buffer, current_cartesian_pos_tag, x, y, z, rot1, rot2, rot3))
        return S_FALSE;
    
    if (!read_cartesian_based_tag(buffer, setpoint_cartesian_pos_tag, x_setpoint, y_setpoint, z_setpoint, rot1_setpoint, rot2_setpoint, rot3_setpoint))
        return S_FALSE;

    if (!read_tag_no_arg_uint(buffer, ipoc_tag, ipoc))
        return S_FALSE;

    delete[] buffer;
    return hr;
}

